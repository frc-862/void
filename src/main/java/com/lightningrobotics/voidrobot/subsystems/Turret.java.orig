package com.lightningrobotics.voidrobot.subsystems;

import java.util.Map;
import java.util.function.DoubleSupplier;

import com.lightningrobotics.common.controller.PIDFController;
import com.lightningrobotics.voidrobot.Constants;
import com.lightningrobotics.voidrobot.commands.TurnTurret;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.RelativeEncoder;

import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class Turret extends SubsystemBase {

	private double turretkP = Constants.TURRET_kP;
	private CANSparkMax turretMotor;
	private RelativeEncoder turretEncoder;

	private final PIDFController pid = new PIDFController(Constants.TURRET_kP, 0, 0);

	private ShuffleboardTab turretTab = Shuffleboard.getTab("turret");
	// private NetworkTableEntry targetDegrees;
	// private NetworkTableEntry currentTargetAngel;
	// private NetworkTableEntry currentDegrees;
	// private NetworkTableEntry targetEntry;
	// private NetworkTableEntry kPEntry;

	private static double target;
	private static double turretTarget = 0;
	private static final double DEFAULT_TARGET = 0;

	private static boolean isDone = false;

	public Turret() {

		turretMotor = new CANSparkMax(Constants.TURN_TURRET_ID, MotorType.kBrushless); // TODO: change CAN ids for both motors
		turretMotor.setIdleMode(CANSparkMax.IdleMode.kCoast);
		turretMotor.setClosedLoopRampRate(.02);
		turretEncoder = turretMotor.getEncoder();

		// targetDegrees = turretTab
		// .add("current turret target", 0)
		// .getEntry();
		// currentTargetAngel = turretTab
		// .add("current target Angel", 0)
		// .getEntry();
		// currentDegrees = turretTab
		// .add("current turret degrees", turretRevToDeg())
		// .getEntry();
		// targetEntry = turretTab
		// .add("target", DEFAULT_TARGET)
		// .withWidget(BuiltInWidgets.kNumberSlider)
		// .withProperties(Map.of("min", -360, "max", 360)) // specify widget properties
		// here
		// .getEntry();
		// kPEntry = turretTab
		// .add("kP", Constants.TURRET_kP)
		// .getEntry();
	}

	public void setTargetAngle(double degrees) {
		target = getTurretAngle() + degrees; // TODO: might not be needed if we are taking target param in twist turret
	}

	// public void twistTurret(double targetAngle) { // -135 -> 135

	// 	// double motorPower = pid.calculate(turretMotor.get(), power);

	// 	// if(motorPower > 1) { // TODO lightning math constrain?
	// 	// motorPower = 1;
	// 	// } else if (motorPower <- 1) { // TODO: have them explain this code
	// 	// motorPower = -1;
	// 	// }

	// 	double motorPower = 0.2; // TOOD: change the speed lamo

	// 	turretTarget += targetAngle;

	// 	if (turretTarget > 180) {
	// 		turretTarget -= 360;
	// 	}
	// 	if (turretTarget < -180) {
	// 		turretTarget += 360;
	// 	}

	// 	// error = turretTarget - turret.turretRevToDeg();

	// 	// if(turretTarget >= 135) {
	// 	// error = 135 - turret.turretRevToDeg();
	// 	// leds.setAllRGB(255, 0, 0);
	// 	// } else if(turretTarget <= -135) {
	// 	// error = -135 - turret.turretRevToDeg(); // basically sets turretTarget to 135
	// 	// without changing turretTarget so the turret can wrap around
	// 	// leds.setAllRGB(255, 0, 0);
	// 	// } else if(Math.abs(error) > 5) { //TODO: tune the compliance angle, add
	// 	// vision
	// 	// leds.setAllRGB(255, 255, 0);
	// 	// } else {
	// 	// leds.setAllRGB(0, 255, 0);
	// 	// }

	// 	// if (Math.abs(error) < 1) {
	// 	// isDone = true; //TODO: fix later
	// 	// }

	// 	turret.twistTurret(error, turretTarget); // input target here

	// 	// targetDegrees.setDouble(turretTarget);
	// 	// currentTargetAngel.setDouble(target);

	// 	turretMotor.set(motorPower);
	// }

	public void stopTurret() {
		turretMotor.set(0);
	}

	public double getTurretAngle() {
		return turretEncoder.getPosition() * 360 / Constants.TURN_TURRET_GEAR_RATIO;;
	}

	public double getEncoderValue() {
		return turretEncoder.getPosition();
	}

	@Override
	public void periodic() {

		// TODO calculate

		// twistTurret(targetEntry.getDouble(DEFAULT_TARGET));
		// turretkP = kPEntry.getDouble(turretkP);
		// currentDegrees.setDouble(turretRevToDeg());
	}
}